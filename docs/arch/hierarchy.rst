Block Hierarchy
===============

There are a number of different types of Blocks in Malcolm, organised into 3
layers as shown by the following diagram:

.. uml::

    !include docs/style.iuml

    () "CA to EPICS IOCs" as CA
    () "TCP to Zebra2 hardware" as TCP

    cloud "Hardware layer" {
        frame DetDrv {
        }
        frame PosLabel {
        }
        frame HDFWriter {
        }
        frame Motor1 {
        }
        frame Traj {
        }
        DetDrv .down.> CA : via
        PosLabel .down.> CA : via
        HDFWriter .down.> CA : via
        Motor1 .down.> CA : via
        Traj .down.> CA : via
    }

    cloud "Device layer" {
        frame ZebraManager {
            [PCOMP] -right-> [PCAP] : Triggers
            [PCOMP] .down.> TCP : via
            [PCAP] .down.> TCP : via
        }
        frame DetectorManager {
            [Det\nDrv\nClient] .down.> DetDrv : Client of
            [Pos\nLabel\nClient] .down.> PosLabel : Client of
            [HDF\nWriter\nClient] .down.> HDFWriter : Client of
            [Det\nDrv\nClient] -right-> [Pos\nLabel\nClient] : Arrays
            [Pos\nLabel\nClient] -right-> [HDF\nWriter\nClient] : Arrays
        }
        frame MotorControllerManager {
            [Motor1\nClient] .down.> Motor1 : Client of
            [Traj\nClient] .down.> Traj : Client of
        }
    }

    cloud "Co-ordination layer" {
        frame BeamlineManager {
            [Zebra\nClient] .down.> ZebraManager : Client of
            [Detector\nClient] .down.> DetectorManager : Client of
            [MotorController\nClient] .down.> MotorControllerManager : Client of
            [Zebra\nClient] -up-> [SpiralScan] : Used by
            [Detector\nClient] -up-> [SpiralScan] : Used by
            [MotorController\nClient] -up-> [SpiralScan] : Used by
        }
    }

    () "pvAccess or WebSockets from GDA/Web GUI" as GDA
    GDA .down.> BeamlineManager : via

Working from the bottom up:

- The Hardware layer contains simple `Hardware interface`_ blocks with no logic
  in them. These generally map one-to-one with an EPICS database via channel
  access.

- The Device layer contains `Manager`_ blocks that correspond to logical pieces
  of hardware, like a Detector or a Motor Controller. They manage a number of
  child `Hardware interface`_ blocks, either by containing the blocks directly,
  or via clients to these blocks. Wiring between the child blocks can be changed
  and settings saved and loaded. These settings will typically be set by the
  controls or data acquisition contact for the beamline, but can also be
  modified at runtime by expert users like beamline scientists.

- The Co-ordination layer also contains `Manager`_ blocks, but these contain
  child `Manager`_ blocks from the Device layer and `Co-ordination`_ blocks that
  control a number of blocks from the Device layer to perform scans. There will
  be relatively few `Manager`_ blocks in this layer, one for each coherent set
  of equipment to be scanned (i.e. one for each independant experimental
  end-station). There will be many different settings for each, one for each
  experiment type, and maybe even one per experiment. GDA will talk to blocks in
  this layer.

Most of the time, all of these blocks will be hosted in the same process on the
same machine, but there is nothing to stop blocks being distributed among
process or different machines. Each `Client of` relationship can travel over
any of the transport protocols that Malcolm supports.

Hardware interface
------------------

Blocks of this type have only the default statemachine. They have no
configuration function, just attributes that map directly to the underlying PVs
or hardware attributes. They are generated by the module owner and also serve as
documentation as to which PVs are externally important.

We introduce here the configuration language for creating Blocks from Parts, it
is valid YAML, but we are only using a limited subset of it.

.. highlight:: yaml

This is a detector driver block::

    # define initialisation attributes
    init.String:
        name: prefix
        description: PV Prefix
        required: true

    # top level groups of parameters
    gui.Group:
        name: configuration
        label: Configuration Parameters
        description: These will be used to configure the device

    # a PV Attribute, one that connects to a demand and readback PV
    ca.Double:
        name: exposure
        description: Exposure time for each frame
        pv: {prefix}:Exposure
        rbv_suffix: _RBV
        widget: textinput
        group: configuration

    ca.LongString:
        name: xml
        description: XML describing positions to tag NDArrays with
        pv: {prefix}:Filename
        widget: textarea
        group: configuration
        writeable: true

    ca.Enum:
        name: acquire
        description: Whether it is acquiring or not
        pv: {prefix}:Acquire
        widget: toggle
        writeable: true

This has then defined the PV interface for a particular template, and nothing
else. The default stateMachine is included, but no methods are created, and the
attributes map directly onto PVs. The writeable PVs have a put method.

All of these will call ca.create_pv(), monitor the resulting PV, and keep a
local attribute in sync with this value. If writeable, it will create a setter
on the attribute that does a caput callback on the PV, doing a get on the RBV
value to avoid the race condition on return.

Manager
-------

Manager Blocks are responsible for the connections between a number of child
Blocks, and are used to setup its children into a particular design
to expose a simple interface to the layer above. Some Manager blocks are
responsible for creating their child Blocks (like Zebra2 where the hardware
allows itself to be introspected) and others manage some externally created
blocks (like the BeamlineManager). They expose an interface according to their
Controller, but the user can modify their behaviour at runtime by loading and
saving settings which will modify the loaded Parts, and hence the top level
interface of the Block. They have the :ref:`runnable-device-state-machine` with
all its related Methods.

.. uml::

    class Manager {
        enum design
        Editor editor
        Part[] parts
        configure()
        run()
    }
    class Editor {
        string design
        bool modified
        PalletteTable pallette
        ExportTable exports
        FollowerTable followers
        load(enum design)
        save(String design)
        set_visible(string block_name, bool visible)
        set_position(string block_name, float xcoord, float ycoord)
    }
    class PalletteTable {
        string[] name
        Block[] block
        int[] xcoord
        int[] ycoord
        bool[] enabled
    }
    Manager *- Editor
    Editor *- PalletteTable
    '* Needed otherwise vim thinks rest of doc is bold...
    PalletteTable o- "0.." Block


The Manager Block also contains an Editor Block which is responsible for the
load/save interface, as well as the pallette of child blocks and their layout,
which is stored as an Attribute:

    ======= =================== ======= ======= ========
    PalletteTable
    ----------------------------------------------------
    Name    Fullname            XCoord  YCoord  Visible
    ======= =================== ======= ======= ========
    PCOMP1  BL18I:Z1:PCOMP1     12      15      Yes
    PCOMP2  BL18I:Z1:PCOMP2     0       0       No
    PCAP    BL18I:Z1:PCAP       200     230     Yes
    ======= =================== ======= ======= ========

This is used by the Zebra2 Web Gui to show a canvas with a number of Blocks
wired together, and the positions they should be drawn at. Each child Block has
a Part associated with it that will be loaded if the Block is marked as active.

The Editor Block also has a number of Table attributes that categorizes each
writeable attribute of each child Block into one of 3 categories:

- **Export**

    ======= =============== ====================
    ExportTable
    --------------------------------------------
    Name    Source          Description
    ======= =============== ====================
    Arm     PCAP.ARM        Start the experiment
    Start   PCOMP1.START
    ======= =============== ====================

  Each line of the table will create an ExportPart for the specified child
  Attribute. If the child Attribute is changed, the export changes, and if the
  child Attribute is writeable then writes to the Manager Attribute will
  propagate to the child Attribute. If the child Attribute is writeable it will
  also add it to the configure() Method arguments.

- **Follower**

    =============== ======
    FollowerTable
    ----------------------
    Name            Source
    =============== ======
    PCOMP2.START    Start
    =============== ======

  This makes a child Attribute a follower of an existing Manager Attribute. If
  the Manager Attribute is changed then the child Attribute will be set to the
  same value. If the child Attribute changes then the Manager device goes into
  Fault state.

- **Fixed**

  On save(), a FixedPart will be generated for every writeable attribute
  that is not mentioned in the exports or followers table. When the Manager is
  reset, the value of the child Attribute is set to the fixed value. If the
  child Attribute changes to another value, the Manager goes into Fault state.

When any of these three tables are changed, the top level Manager Block is
Disabled and the Parts reloaded.

The Editor Block also has a model Attribute that will set the metaOf property
in the Block structure so that anyone using this Block will know what model it
conforms to.

Manager blocks fix the child blocks that they manage, as well as controller
logic for each of them when they are constructed::

    init.String:
        name: pvprefix
        description: Prefix for all child objects pvs

    controller.AreaDetectorController:
        design: simDetectorDefaultSetup

    # will prefix name with manager prefix
    block.ADCore.PositionPlugin:
        name: pos
        prefix: {pvprefix}
        part: PosPluginPart

    # Attach to existing block
    client.ADCore.DetectorDriver:
        name: drv
        fullname: sim:drv
        part: DriverRunPart
        readonly: False

Save and load settings will also be written in YAML::

    parts.ModelPart:
        name: PositionBased

    parts.PalettePart:
        name: PCOMP1
        xcoord: 12
        ycoord: 15
        visible: Yes

    parts.PalettePart:
        name: PCOMP2
        xcoord: 0
        ycoord: 0
        visible: No

    parts.PalettePart:
        name: PCAP
        xcoord: 200
        ycoord: 230
        visible: Yes

    parts.ExportPart:
        name: Arm
        source: PCAP.START
        description: Start the experiment

    parts.ExportPart:
        name: Start
        source: PCOMP1.START

    parts.FollowerPart:
        name: PCOMP2.START
        source: Start

    fixed.Int:
        name: PCOMP2.WIDTH
        value: 32

    fixed.Table:
        name: SEQ1.TABLE
        value:
            - Phase1Time: 32
              Phase2Time: 45
              NRepeats: 3
            - Phase1Time: 3
              Phase2Time: 5
              NRepeats: 1

Parts
-----

The Controller will provide all the configure/run/pause/retrace methods, and a
number of hooks that Parts can hook into. For instance, the exported attributes
use this hook to allow setting of that attribute during configure. As well as a
hook for each state, the AreaDetectorController implementation of the
RunnableDevice statemachine will define substate hooks for specific operations,
so for the running states we have hooks for:

- PreRunPluginStart
- PreRunDriverStart
- Running
- PostRun

It will also contain the attributes needed to configure any common
functionality, for instance the ScanPointGenerator instance that the position
plugin and hdfwriter will use to place frames in the file. It will also contain
a reference back to its Configuration Manager block so that when it is
activated, the currently active block can be deactivated.

.. highlight:: python

These hooks can be used to make sure that configure and run operations are
sequenced in the correct order. The hooked functions will be run concurrently
in each phase, and the phase won't advance until they have all completed. For
example, a position plugin might look like this::

    from malcolm.core import ChildControllerPart, Controls
    from malcolm.sm import AreaDetectorRunnableDevice
    from malcolm.modules.ADCore import PositionPlugin


    @Controls(PositionPlugin)
    class PosPluginPart(ChildControllerPart):

        def _generate_xml(self, start, num):
            # Generate some XML to be sent down to the PositionPlugin that
            # represents the next num positions after start
            return "<xml_goes_here/>"

        @AreaDetectorRunnableDevice.Configure
        def configure(self, task, device):
            pos = self.child
            # start some puts off in the background
            futures = task.put_async({
                pos.delete: True,
                pos.idStart: 1,
                pos.enableCallbacks: True})
            # calculate the first 100 positions
            xml = self._generate_xml(0, 100)
            # wait until puts are done
            task.wait_all(futures)
            # put the first 100 points
            task.put(pos.xml, xml)
            self._loaded = 100

        def _load_pos(self, device, positions):
            pos = self.child
            if positions < 100 and self._loaded < device.totalSteps:
                # add up to 100 more positions
                num = min(100, device.totalSteps - self._loaded)
                xml = self._generate_xml(self._loaded, num)
                pos.xml.put(xml)
                self._loaded += num

        @AreaDetectorRunnableDevice.PreRunPluginStart
        def start_plugin(self, task, device):
            pos = self.child
            # Each time the number of positions left changes, call a function
            # to load positions if we're getting low
            # This will live until we unsubscribe from the self.load_id
            self.load_id = task.subscribe(pos.positions, self._load_pos, device)
            # Start us off running
            running_f = task.when_matches(pos.running, True)
            self.done_f = task.put_async(pos.start, True)
            task.wait_all(running_f)

        @AreaDetectorRunnableDevice.Running
        def running(self, task, device):
            task.wait_all(self.done_f)
            task.unsubscribe(self.load_id)

Co-ordination
-------------

Blocks like SpiralScan co-ordinate a number of Blocks in the Device layer. They
will typically be represented as Blocks in the BeamlineManager palette. They
will be formed of composition of a number of underlying Parts that control the
child Devices, and Parts that either take a ScanPointGenerator or the
parameters to construct one. In this way, many scan types can be created for
testing, but the generic case can be used by GDA to do whatever scan they need.

.. highlight:: yaml

An example for the generic case might look like this::

    init.ADCore.DetectorDriver:
        name: det
        description: Detector name to connect to

    init.zebra2.Zebra:
        name: zebra
        description: Zebra name to connect to

    init.motor.MotorController:
        name: motor
        description: Motor controller to connect to

    controller.GenericScanController:

    parts.DetectorPart:
        input: {det}

    parts.ZebraPart:
        input: {zebra}

    parts.MotorPart:
        input: {motor}

