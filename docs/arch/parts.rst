Blocks and Parts
================

Blocks, Methods, and Attributes are what is exposed by Malcolm at run-time.
However, during the first iteration of Malcolm, it became apparent that
Python classes that implemented Blocks were too large and unweildy to easily
share code. Likewise, Attributes and Methods were too small, what is needed is
a collection of a small number of Attributes and Methods that form a coherent
reusable group. We will call these `Parts`. Blocks will be formed as a
composition of Parts, and to avoid repeating ourselves, we will define a
configuration language written in YAML.

A Block would be created by parsing a YAML file for initialisation Attributes,
taking values for those, and creating an object composed of the component parts.
Different component parts will typically be used depending on the function of
the block. There are 4 types of block that live in a 2 layer hierarchy:

.. uml::
    !include docs/style.iuml

    frame "Co-ordination layer" {
        [GDA CPU scan 2]
        [GDA CPU scan]
        [Spiral scan]
    }

    note top of [GDA CPU scan 2] : Only one active at once

    frame "Hardware layer" {
        cloud "Detector manager" {
            [Position\nlabeller] -right-> [HDF\nwriter]
            [Detector\ndriver] -right-> [Position\nlabeller]
            [Detector\nDevice] -down- [HDF\nwriter]
            [Detector\nDevice] -down- [Position\nlabeller]
            [Detector\nDevice] -down- [Detector\ndriver]
            [Detector\nDevice 2] -down- [HDF\nwriter]
            [Detector\nDevice 2] -down- [Position\nlabeller]
        }

        cloud "Zebra2 manager" {
            [Zebra2\nDevice] -down- [PCOMP]
            [Zebra2\nDevice] -down- [PCAP]
            [PCOMP] -right-> [PCAP]
        }

        [Motor\nDevice] -down- [Traj]
        [Traj]
    }

    [GDA CPU scan 2] - [Detector\nDevice 2]
    [GDA CPU scan] - [Detector\nDevice]
    [Spiral scan] - [Detector\nDevice]
    [Spiral scan] - [Zebra2\nDevice]
    [Spiral scan] - [Motor\nDevice]

The hardware layer contains simple `Hardware interface`_ blocks with no logic in
them, `Manager`_ blocks that allow rewiring and save/load functionality and
`Device`_ blocks that encapsulate a single saved setup of a number of
underlying blocks with the configure/run logic to use them.

The `Co-ordination`_ layer contains blocks that use a number of `Device`_ blocks
to do specific scans.

Hardware interface
------------------

Blocks of this type have only the default statemachine. They have no
configuration function, just attributes that map directly to the underlying PVs
or hardware attributes. They are generated by the module owner and also serve as
documentation as to which PVs are externally important.

.. highlight:: yaml

This is a detector driver block::

    # define initialisation attributes
    init.String:
        name: prefix
        description: PV Prefix
        required: true

    # top level groups of parameters
    gui.Group:
        name: configuration
        label: Configuration Parameters
        description: These will be used to configure the device

    # a PV Attribute, one that connects to a demand and readback PV
    ca.Double:
        name: exposure
        description: Exposure time for each frame
        pv: {prefix}:Exposure
        rbv_suff: _RBV
        widget: textinput
        group: configuration

    ca.LongString:
        name: xml
        description: XML describing positions to tag NDArrays with
        pv: {prefix}:Filename
        widget: textarea
        group: configuration
        writeable: true

    ca.Enum:
        name: acquire
        description: Whether it is acquiring or not
        pv: {prefix}:Acquire
        labels:
            - Idle
            - Acquire
        widget: toggle
        writeable: true

This has then defined the PV interface for a particular template, and nothing
else. The default stateMachine is included, but no methods are created, and the
attributes map directly onto PVs. The writeable PVs have a put method.

All of these will call ca.create_pv(), monitor the resulting PV, and keep a
local attribute in sync with this value. If writeable, it will create a setter
on the attribute that does a caput callback on the PV, doing a get on the RBV
value to avoid the race condition on return.

Manager
-------

Blocks in the `Hardware interface`_ expose a very thin layer over the underlying
hardware. They are typically multipurpose blocks that could be combined in a
number of ways. Manager Blocks are responsible for the connections
between a number of hardware blocks, loading and saving configurations for them,
and marking them as active or inactive. Zebra2 web gui will communicate with one
of these managers, but the same principle and gui can be applied to areaDetector
plugin chains. Each load or save creates a `Device`_ Block, with each writeable
attribute of the child `Hardware interface`_ layer belonging to one of 3
categories:

- mirror: this creates a `Device`_ attribute that is a mirror of the child
  attribute. If the child attribute is changed, the mirror changes, and if the
  child attribute is writeable then writes to the `Device`_ attribute will
  propagate to the child attribute. If the child attribute is writeable it will
  also add it to a list of configurable fields.

  There is a table in the Manager block allowing these mappings to be edited:

    ======= =============== ====================
    Mirrors
    --------------------------------------------
    Name    Source          Description
    ======= =============== ====================
    Arm     PCAP.START      Start the experiment
    Start   PCOMP1.START
    ======= =============== ====================

- slave: this slaves a child attribute to an existing `Device`_ attribute. If
  the `Device`_ attribute is changed then the child attribute will be set to the
  same value. If the child attribute changes then the `Device`_ device goes into
  Fault state.

  There is another table in the Manager block for these mappings:

    =============== ======
    Slaves
    ----------------------
    Name            Source
    =============== ======
    PCOMP2.START    Start
    =============== ======

- fixed: during reset, the value of the child attribute is set. If it is changed
  by someone other than the `Device`_ device, the `Device`_ device goes into
  Fault state.

  Any attribute that is not covered in the Mirrors and Slaves table of the
  Manager block will be fixed on save.

Manager blocks fix the child blocks that they manage, as well as controller
logic for each of them when they are constructed::

    init.String:
        name: pvprefix
        description: PV prefix for all child objects

    # Defines prefix for all block names below
    sm.PluginManager:
        creates: sm.AreaDetectorRunnableDevice

    # will prefix name with manager prefix
    modules.ADCore.PositionPlugin:
        name: pos
        prefix: {pvprefix}
        controller: PosController

Device
------

These are parent blocks that summarize a number of child blocks in the
CA/hardware interface layer. They contain a mapping of configuration parameters
to the underlying blocks, and generally have the
:ref:`runnable-device-state-machine`. They can be generated by a block in the
`Manager`_ layer, or manually. They fix the setup of a particular group of
blocks, and expose a small number of user configurable parameters to the higher
level. For example::

    # Create self.exposure deferring puts to detectorDriver.exposure
    mirror.detectorDriver.exposure:
        name: exposure
    # set detectorDriver2 exposure whenever self.exposure changes
    slave.detectorDriver2.exposure:
        source: exposure
    # set positionPlugin.enabled=1 on reset
    fixed.positionPlugin.enabled:
        value: 1

Tables can be represented as repeated key value pairs::

    fixed.detectorDriver2.positions:
        value:
            - x: 32
              y: 45
            - x: 33
              y: 46


However, this doesn't address how to implement a configure/run statemachine on
top of these attributes. For this we need to instantiate the base statemachine
that will allow the various states::

    sm.AreaDetectorRunnableDevice:
        manager: {manager}

This will provide all the configure/run/pause/retrace methods, and a number of
hooks that Parts can hook into. For instance, the mirrored attributes use this
hook to allow setting of that attribute during configure. As well as a hook for
each state, the AreaDetectorRunnableDevice statemachine will define substate
hooks for specific operations, so for the running states we have hooks for:

- PreRunPluginStart
- PreRunDriverStart
- Running
- PostRun

It will also contain the attributes needed to configure any common
functionality, for instance the ScanPointGenerator instance that the position
plugin and hdfwriter will use to place frames in the file. It will also contain
a reference back to its Configuration Manager block so that when it is
activated, the currently active block can be deactivated.

.. highlight:: python

These hooks can be used to make sure that configure and run operations are
sequenced in the correct order. The hooked functions will be run concurrently
in each phase, and the phase won't advance until they have all completed. For
example, a position plugin might look like this::

    from malcolm.core import ChildControllerPart, Controls
    from malcolm.sm import AreaDetectorRunnableDevice
    from malcolm.modules.ADCore import PositionPlugin


    @Controls(PositionPlugin)
    class PosController(ChildControllerPart):

        @AreaDetectorRunnableDevice.Configure
        def configure(self, task, device):
            pos = self.child
            # start some puts off in the background
            future = task.put_async({
                pos.delete: True,
                pos.idStart: 1,
                pos.enableCallbacks: True})
            # calculate the first 100 positions
            xml = self._generate_xml(0, 100)
            # wait until puts are done
            task.wait_all(future)
            # put the first 100 points
            task.put(pos.xml, xml)
            self._loaded = 100

        def _load_pos(self, positions):
            pos = self.child
            if positions < 100 and self._loaded < self.device.totalSteps:
                # add up to 100 more positions
                num = min(100, self.device.totalSteps - self._loaded)
                xml = self._generate_xml(self._loaded, num)
                pos.xml.put(xml)
                self._loaded += num

        @AreaDetectorRunnableDevice.PreRunPluginStart
        def start_plugin(self, task, device):
            pos = self.child
            # Each time the number of positions left changes, call a function
            # to load positions if we're getting low
            # This will live for as long as the self.load_f future does
            self.load_f = task.listen(pos.positions, self._load_pos)
            # Start us off running
            running_f = task.when_matches(pos.running, True)
            self.done_f = task.put_async(pos.start, True)
            task.wait_all(running_f)

        @AreaDetectorRunnableDevice.Running
        def running(self, task, device):
            task.wait_all(self.done_f)
            self.load_f.cancel()

.. highlight:: yaml

This would be instantiated by::

    controller.PosController:

Co-ordination
-------------

These are the highest level entry point, and will typically be used directly
from GDA. They will have the RunnableDevice statemachine. They will adapt to the
detectors and motors that they are given at configuration, and do a complete
mapping scan by controlling `Device`_ blocks. We can specify the child blocks at
init::

    init.DetectorsArray:
        name: detectors
        description: Detector instances to be triggered
        required: true
        trackError: true

There will be some statemachine hooks just for this layer, but they are not
defined yet::

    sm.SupervisoryRunnableDevice:

